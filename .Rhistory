if (!is.logical(apartments_private)) {
apartments_private <- apartments_private == "True"
}
if (!is.logical(houses_private)) {
houses_private <- houses_private == "True"
}
# Skaičiuojame privačių pardavėjų kiekį kiekviename rinkos segmente
apartments_private_count <- sum(apartments_private)
houses_private_count <- sum(houses_private)
# Bendras kiekvieno segmento dydis
apartments_total <- length(apartments_private)
houses_total <- length(houses_private)
# Proporcijų apskaičiavimas
apartments_prop <- apartments_private_count / apartments_total
houses_prop <- houses_private_count / houses_total
prop_test_results <- prop.test(
x = c(apartments_private_count, houses_private_count),
n = c(apartments_total, houses_total),
alternative = "two.sided",
correct = TRUE # Taikoma Yates pataisa
)
print(prop_test_results)
alpha <- 0.05
df <- 1
critical_chi_sq <- qchisq(1 - alpha, df)
critical_chi_sq
# Ištraukiame reikalingus duomenis
premises_area <- as.numeric(gsub(",", ".", as.character(csv_data_list[["premises"]]$area)))
premises_rent_area <- as.numeric(gsub(",", ".", as.character(csv_data_list[["premises_rent"]]$area)))
# Pašaliname NA ir nelogiškas reikšmes
premises_area <- premises_area[!is.na(premises_area) & premises_area > 0 & premises_area < 10000]
premises_rent_area <- premises_rent_area[!is.na(premises_rent_area) & premises_rent_area > 0 & premises_rent_area < 10000]
f_test_results <- var.test(
premises_area, premises_rent_area, alternative = "two.sided")
print(f_test_results)
# Filtruojame ir atspausdiname renovuotus ir nerenovuotus butus su jų kainomis
build_year_data <- csv_data_list[["apartments_rent"]]$build_year
price_data <- csv_data_list[["apartments_rent"]]$price
# Sukuriame pilną duomenų rinkinį
full_data <- data.frame(
build_year = build_year_data,
price = price_data
)
renovated_data <- data.frame(
build_year = character(0),
price = numeric(0),
construction_year = numeric(0)
)
for (i in 1:nrow(full_data)) {
x <- as.character(full_data$build_year[i])
if (grepl("construction", x) && grepl("renovation", x)) {
construction_year <- as.numeric(substr(x, 1, 4))
renovation_year <- as.numeric(substr(x, regexpr("renovation", x) - 5, regexpr("renovation", x) - 2))
if (!is.na(construction_year) && !is.na(renovation_year) && construction_year < 2000 && renovation_year > 2010) {
renovated_data <- rbind(renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
}
}
# Pervardijame renovuotų butų stulpelius
if (nrow(renovated_data) > 0) {
colnames(renovated_data)[1:2] <- c("build_year_renovated", "price_renovated")
}
# Identifikuojame nerenovuotus butus ir ištraukiame jų statybos metus
non_renovated_data <- data.frame(
build_year = character(0),
price = numeric(0),
construction_year = numeric(0)
)
for (i in 1:nrow(full_data)) {
x <- as.character(full_data$build_year[i])
if (!grepl("renovation", x)) {
# Jei statybos metai pateikti kaip skaičius
if (grepl("^\\d{4}$", x)) {
construction_year <- as.numeric(x)
if (!is.na(construction_year)) {
non_renovated_data <- rbind(non_renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
} else if (grepl("construction", x)) {
# Jei yra "construction" formatas
construction_year <- as.numeric(substr(x, 1, 4))
if (!is.na(construction_year)) {
non_renovated_data <- rbind(non_renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
}
}
}
# Pervardijame nerenovuotų butų stulpelius
if (nrow(non_renovated_data) > 0) {
colnames(non_renovated_data)[1:2] <- c("build_year_non_renovated", "price_non_renovated")
}
# Sukuriame lentelę rezultatams
combined_data <- data.frame(
ID_Renovuoto = numeric(nrow(renovated_data)),
Statybos_Metai_Renovuoto = character(nrow(renovated_data)),
Statybos_Metai_Skaicius_Renovuoto = numeric(nrow(renovated_data)),
Kaina_Renovuoto = numeric(nrow(renovated_data)),
ID_Nerenovuoto = numeric(nrow(renovated_data)),
Statybos_Metai_Skaicius_Nerenovuoto = numeric(nrow(renovated_data)),
Kaina_Nerenovuoto = numeric(nrow(renovated_data))
)
# Užpildome lentelę duomenimis
for (i in 1:nrow(renovated_data)) {
target_year <- renovated_data$construction_year[i]
# Randame nerenovuotus butus su tokiais pačiais statybos metais
matching_indices <- which(non_renovated_data$construction_year == target_year)
if (length(matching_indices) > 0) {
# Jei yra sutampančių statybos metų, parenkame atsitiktinį butą iš jų
random_idx <- sample(matching_indices, 1)
} else {
next
}
# Užpildome duomenis
combined_data[i, "ID_Renovuoto"] <- i
combined_data[i, "Statybos_Metai_Renovuoto"] <- as.character(renovated_data[i, "build_year_renovated"])
combined_data[i, "Statybos_Metai_Skaicius_Renovuoto"] <- renovated_data$construction_year[i]
combined_data[i, "Kaina_Renovuoto"] <- renovated_data[i, "price_renovated"]
combined_data[i, "ID_Nerenovuoto"] <- random_idx
combined_data[i, "Statybos_Metai_Skaicius_Nerenovuoto"] <- non_renovated_data$construction_year[random_idx]
combined_data[i, "Kaina_Nerenovuoto"] <- non_renovated_data[random_idx, "price_non_renovated"]
}
# Pašaliname eilutes su NA reikšmėmis
combined_data_clean <- combined_data[complete.cases(combined_data), ]
# Papildomai pašaliname eilutes, kur Kaina_Renovuoto yra 0
combined_data_clean <- combined_data_clean[combined_data_clean$Kaina_Renovuoto > 0, ]
par(mfrow=c(2,2))
hist(combined_data_clean$Kaina_Renovuoto, main="Renovuotų butų kainų pasiskirstymas",
xlab="Kaina (EUR)")
hist(combined_data_clean$Kaina_Nerenovuoto, main="Nerenovuotų butų kainų pasiskirstymas",
xlab="Kaina (EUR)")
# QQ grafikai
qqnorm(combined_data_clean$Kaina_Renovuoto, main="Renovuotų butų QQ grafikas")
qqline(combined_data_clean$Kaina_Renovuoto)
qqnorm(combined_data_clean$Kaina_Nerenovuoto, main="Nerenovuotų butų QQ grafikas")
qqline(combined_data_clean$Kaina_Nerenovuoto)
log_kaina_renovuoto <- log(combined_data_clean$Kaina_Renovuoto)
log_kaina_nerenovuoto <- log(combined_data_clean$Kaina_Nerenovuoto)
hist(log_kaina_renovuoto, main="Log-transformuotos renovuotų butų kainos",
xlab="ln(Kaina)")
hist(log_kaina_nerenovuoto, main="Log-transformuotos nerenovuotų butų kainos",
xlab="ln(Kaina)")
qqnorm(log_kaina_renovuoto, main="Log-renovuotų butų QQ grafikas")
qqline(log_kaina_renovuoto)
qqnorm(log_kaina_nerenovuoto, main="Log-nerenovuotų butų QQ grafikas")
qqline(log_kaina_nerenovuoto)
# Filtruojame ir atspausdiname renovuotus ir nerenovuotus butus su jų kainomis
build_year_data <- csv_data_list[["apartments_rent"]]$build_year
price_data <- csv_data_list[["apartments_rent"]]$price
# Sukuriame pilną duomenų rinkinį
full_data <- data.frame(
build_year = build_year_data,
price = price_data
)
renovated_data <- data.frame(
build_year = character(0),
price = numeric(0),
construction_year = numeric(0)
)
for (i in 1:nrow(full_data)) {
x <- as.character(full_data$build_year[i])
if (grepl("construction", x) && grepl("renovation", x)) {
construction_year <- as.numeric(substr(x, 1, 4))
renovation_year <- as.numeric(substr(x, regexpr("renovation", x) - 5, regexpr("renovation", x) - 2))
if (!is.na(construction_year) && !is.na(renovation_year) && construction_year < 2000 && renovation_year > 2010) {
renovated_data <- rbind(renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
}
}
# Pervardijame renovuotų butų stulpelius
if (nrow(renovated_data) > 0) {
colnames(renovated_data)[1:2] <- c("build_year_renovated", "price_renovated")
}
# Identifikuojame nerenovuotus butus ir ištraukiame jų statybos metus
non_renovated_data <- data.frame(
build_year = character(0),
price = numeric(0),
construction_year = numeric(0)
)
for (i in 1:nrow(full_data)) {
x <- as.character(full_data$build_year[i])
if (!grepl("renovation", x)) {
# Jei statybos metai pateikti kaip skaičius
if (grepl("^\\d{4}$", x)) {
construction_year <- as.numeric(x)
if (!is.na(construction_year)) {
non_renovated_data <- rbind(non_renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
} else if (grepl("construction", x)) {
# Jei yra "construction" formatas
construction_year <- as.numeric(substr(x, 1, 4))
if (!is.na(construction_year)) {
non_renovated_data <- rbind(non_renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
}
}
}
# Pervardijame nerenovuotų butų stulpelius
if (nrow(non_renovated_data) > 0) {
colnames(non_renovated_data)[1:2] <- c("build_year_non_renovated", "price_non_renovated")
}
# Sukuriame lentelę rezultatams
combined_data <- data.frame(
ID_Renovuoto = numeric(nrow(renovated_data)),
Statybos_Metai_Renovuoto = character(nrow(renovated_data)),
Statybos_Metai_Skaicius_Renovuoto = numeric(nrow(renovated_data)),
Kaina_Renovuoto = numeric(nrow(renovated_data)),
ID_Nerenovuoto = numeric(nrow(renovated_data)),
Statybos_Metai_Skaicius_Nerenovuoto = numeric(nrow(renovated_data)),
Kaina_Nerenovuoto = numeric(nrow(renovated_data))
)
# Užpildome lentelę duomenimis
for (i in 1:nrow(renovated_data)) {
target_year <- renovated_data$construction_year[i]
# Randame nerenovuotus butus su tokiais pačiais statybos metais
matching_indices <- which(non_renovated_data$construction_year == target_year)
if (length(matching_indices) > 0) {
# Jei yra sutampančių statybos metų, parenkame atsitiktinį butą iš jų
random_idx <- sample(matching_indices, 1)
} else {
next
}
# Užpildome duomenis
combined_data[i, "ID_Renovuoto"] <- i
combined_data[i, "Statybos_Metai_Renovuoto"] <- as.character(renovated_data[i, "build_year_renovated"])
combined_data[i, "Statybos_Metai_Skaicius_Renovuoto"] <- renovated_data$construction_year[i]
combined_data[i, "Kaina_Renovuoto"] <- renovated_data[i, "price_renovated"]
combined_data[i, "ID_Nerenovuoto"] <- random_idx
combined_data[i, "Statybos_Metai_Skaicius_Nerenovuoto"] <- non_renovated_data$construction_year[random_idx]
combined_data[i, "Kaina_Nerenovuoto"] <- non_renovated_data[random_idx, "price_non_renovated"]
}
# Pašaliname eilutes su NA reikšmėmis
combined_data_clean <- combined_data[complete.cases(combined_data), ]
# Papildomai pašaliname eilutes, kur Kaina_Renovuoto yra 0
combined_data_clean <- combined_data_clean[combined_data_clean$Kaina_Renovuoto > 0, ]
par(mfrow=c(2,2))
hist(combined_data_clean$Kaina_Renovuoto, main="Renovuotų butų kainų pasiskirstymas",
xlab="Kaina (EUR)", col="skyblue")
hist(combined_data_clean$Kaina_Nerenovuoto, main="Nerenovuotų butų kainų pasiskirstymas",
xlab="Kaina (EUR)", col="skyblue")
# QQ grafikai
qqnorm(combined_data_clean$Kaina_Renovuoto, main="Renovuotų butų QQ grafikas")
qqline(combined_data_clean$Kaina_Renovuoto)
qqnorm(combined_data_clean$Kaina_Nerenovuoto, main="Nerenovuotų butų QQ grafikas")
qqline(combined_data_clean$Kaina_Nerenovuoto)
log_kaina_renovuoto <- log(combined_data_clean$Kaina_Renovuoto)
log_kaina_nerenovuoto <- log(combined_data_clean$Kaina_Nerenovuoto)
hist(log_kaina_renovuoto, main="Log-transformuotos renovuotų butų kainos",
xlab="ln(Kaina)", col="skyblue")
hist(log_kaina_nerenovuoto, main="Log-transformuotos nerenovuotų butų kainos",
xlab="ln(Kaina)", col="skyblue")
qqnorm(log_kaina_renovuoto, main="Log-renovuotų butų QQ grafikas")
qqline(log_kaina_renovuoto)
qqnorm(log_kaina_nerenovuoto, main="Log-nerenovuotų butų QQ grafikas")
qqline(log_kaina_nerenovuoto)
library(readxl)
duom <- read_excel("duomenys.xlsx")
equipment_data <- data.frame(
equipment = names(table(duom$equipment)),
count = as.vector(table(duom$equipment))
)
ggplot(equipment_data, aes(x = equipment, y = count)) +
geom_bar(stat = "identity", fill = "skyblue") +
labs(title = "Įrengimo lygio pasiskirstymas",
x = "Įrengimo lygis",
y = "Patalpų skaičius") +
theme_scientific() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Komercinių patalpų ploto analizė
premises_types <- c("premises", "premises_rent")
premises_data <- list()
# Apjungiame duomenis iš abiejų šaltinių
for (type in premises_types) {
if (type %in% names(csv_data_list) && "area" %in% colnames(csv_data_list[[type]])) {
df <- csv_data_list[[type]]
df$type <- ifelse(type == "premises", "Pardavimas", "Nuoma") # Lietuviškas žymėjimas
# Užtikriname, kad plotas būtų skaitinis
df$area <- as.numeric(gsub(",", ".", as.character(df$area)))
# Atmetame nelogiškus ploto dydžius (pvz., neigiamus ar per didelius)
df <- df[!is.na(df$area) & df$area > 0 & df$area < 10000, ]
# Užtikriname, kad visi stulpeliai būtų vienodi abiem šaltiniam (premises ir premises_rent)
if (length(premises_data) > 0) {
# Nustatome bendrus stulpelius tarp esamo ir pridedamo duomenų rinkinių
common_cols <- intersect(colnames(df), colnames(premises_data[[1]]))
# Paliekame tik bendrus stulpelius
df <- df[, common_cols, drop = FALSE]
}
premises_data[[type]] <- df
}
}
# Sujungiame duomenis, užtikrindami stulpelių suderinamumą
if (length(premises_data) == 2) {
# Užtikriname, kad stulpeliai abiem šaltiniuose būtų identiški
common_cols <- intersect(colnames(premises_data[[1]]), colnames(premises_data[[2]]))
premises_data[[1]] <- premises_data[[1]][, common_cols, drop = FALSE]
premises_data[[2]] <- premises_data[[2]][, common_cols, drop = FALSE]
}
# Sujungiame duomenis
combined_premises <- do.call(rbind, premises_data)
# Braižome boxplot
area_boxplot <- ggplot(combined_premises, aes(x = type, y = area, fill = type)) +
geom_boxplot(outlier.color = "red", outlier.size = 1) +
labs(title = "Komercinių patalpų ploto pasiskirstymas",
subtitle = "Pardavimo ir nuomos sektoriuose",
x = "Sektorius",
y = "Plotas (kv. m)") +
theme_scientific() +
theme(legend.position = "none") +
scale_fill_manual(values = c("Pardavimas" = "skyblue", "Nuoma" = "green")) +
scale_y_continuous(labels = comma) +
coord_cartesian(ylim = c(0, 2000))
print(area_boxplot)
df <- csv_data_list[["house_rent"]]
# Standartizuojame ploto stulpelį: pakeičiame kablelius taškais ir konvertuojame į skaičius
df$area <- as.numeric(gsub(",", ".", as.character(df$area)))
# Atmetame nelogiškas reikšmes
df <- df[!is.na(df$area) & !is.na(df$price) &
df$area > 0 & df$area < 500 &
df$price > 0 & df$price < 6000, ]
# Apskaičiuojame kainą už kvadratinį metrą
df$price_per_sqm <- df$price / df$area
# Braižome sklaidos diagramą su regresijos linija
scatter_plot <- ggplot(df, aes(x = area, y = price)) +
geom_point(alpha = 0.7, color = "darkblue") +
geom_smooth(method = "lm", color = "red", se = FALSE) +
labs(title = "Namų nuomos kainos priklausomybė nuo ploto",
subtitle = "Su tiesine regresijos kreive",
x = "Plotas (kv. m)",
y = "Nuomos kaina (EUR/mėn.)") +
theme_scientific() +
scale_color_viridis_c() +
scale_y_continuous(labels = comma) +
scale_x_continuous(labels = comma)
print(scatter_plot)
# Pridedame koreliacijos koeficientą
correlation <- cor(df$area, df$price, use = "complete.obs")
cat("Koreliacijos koeficientas tarp namų ploto ir nuomos kainos:", round(correlation, 3), "\n")
duom$log_price <- log(duom$price)
hist(duom$log_price,
breaks = 100,
col = "skyblue",
main = "Namų kainų pasiskirstymas",
xlab = "Kaina (€)",
ylab = "dažnis")
# Paruošiame duomenis testui kaip ir anksčiau
houses_area <- as.numeric(gsub(",", ".", as.character(csv_data_list[["houses"]]$area)))
apartments_area <- as.numeric(gsub(",", ".", as.character(csv_data_list[["apartments"]]$area)))
# Pašaliname NA ir galimai neteisingus dydžius
houses_area <- houses_area[!is.na(houses_area) & houses_area > 0 & houses_area < 1000]
apartments_area <- apartments_area[!is.na(apartments_area) & apartments_area > 0 & apartments_area < 1000]
# Skirstiniai su histogramomis ir QQ grafikais
par(mfrow=c(2,2))
hist(houses_area, main="Namų ploto pasiskirstymas", xlab="Plotas (kv. m)", breaks=25, col="skyblue")
hist(apartments_area, main="Butų ploto pasiskirstymas", xlab="Plotas (kv. m)", breaks=25, col="skyblue")
qqnorm(houses_area, main="Namų ploto QQ grafikas")
qqline(houses_area)
qqnorm(apartments_area, main="Butų ploto QQ grafikas")
qqline(apartments_area)
# Logaritminė transformacija
log_houses_area <- log(houses_area)
log_apartments_area <- log(apartments_area)
# Logaritmuotų duomenų patikrinimas
hist(log_houses_area, main="Log-transformuotas namų plotas", xlab="log(Plotas)", breaks=25, col="skyblue")
hist(log_apartments_area, main="Log-transformuotas butų plotas", xlab="log(Plotas)", breaks=25, col="skyblue")
qqnorm(log_houses_area, main="Log-namų ploto QQ grafikas")
qqline(log_houses_area)
qqnorm(log_apartments_area, main="Log-butų ploto QQ grafikas")
qqline(log_apartments_area)
par(mfrow=c(1,1))
# Filtruojame ir atspausdiname renovuotus ir nerenovuotus butus su jų kainomis
build_year_data <- csv_data_list[["apartments_rent"]]$build_year
price_data <- csv_data_list[["apartments_rent"]]$price
# Sukuriame pilną duomenų rinkinį
full_data <- data.frame(
build_year = build_year_data,
price = price_data
)
renovated_data <- data.frame(
build_year = character(0),
price = numeric(0),
construction_year = numeric(0)
)
for (i in 1:nrow(full_data)) {
x <- as.character(full_data$build_year[i])
if (grepl("construction", x) && grepl("renovation", x)) {
construction_year <- as.numeric(substr(x, 1, 4))
renovation_year <- as.numeric(substr(x, regexpr("renovation", x) - 5, regexpr("renovation", x) - 2))
if (!is.na(construction_year) && !is.na(renovation_year) && construction_year < 2000 && renovation_year > 2010) {
renovated_data <- rbind(renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
}
}
# Pervardijame renovuotų butų stulpelius
if (nrow(renovated_data) > 0) {
colnames(renovated_data)[1:2] <- c("build_year_renovated", "price_renovated")
}
# Identifikuojame nerenovuotus butus ir ištraukiame jų statybos metus
non_renovated_data <- data.frame(
build_year = character(0),
price = numeric(0),
construction_year = numeric(0)
)
for (i in 1:nrow(full_data)) {
x <- as.character(full_data$build_year[i])
if (!grepl("renovation", x)) {
# Jei statybos metai pateikti kaip skaičius
if (grepl("^\\d{4}$", x)) {
construction_year <- as.numeric(x)
if (!is.na(construction_year)) {
non_renovated_data <- rbind(non_renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
} else if (grepl("construction", x)) {
# Jei yra "construction" formatas
construction_year <- as.numeric(substr(x, 1, 4))
if (!is.na(construction_year)) {
non_renovated_data <- rbind(non_renovated_data, data.frame(
build_year = x,
price = full_data$price[i],
construction_year = construction_year
))
}
}
}
}
# Pervardijame nerenovuotų butų stulpelius
if (nrow(non_renovated_data) > 0) {
colnames(non_renovated_data)[1:2] <- c("build_year_non_renovated", "price_non_renovated")
}
# Sukuriame lentelę rezultatams
combined_data <- data.frame(
ID_Renovuoto = numeric(nrow(renovated_data)),
Statybos_Metai_Renovuoto = character(nrow(renovated_data)),
Statybos_Metai_Skaicius_Renovuoto = numeric(nrow(renovated_data)),
Kaina_Renovuoto = numeric(nrow(renovated_data)),
ID_Nerenovuoto = numeric(nrow(renovated_data)),
Statybos_Metai_Skaicius_Nerenovuoto = numeric(nrow(renovated_data)),
Kaina_Nerenovuoto = numeric(nrow(renovated_data))
)
# Užpildome lentelę duomenimis
for (i in 1:nrow(renovated_data)) {
target_year <- renovated_data$construction_year[i]
# Randame nerenovuotus butus su tokiais pačiais statybos metais
matching_indices <- which(non_renovated_data$construction_year == target_year)
if (length(matching_indices) > 0) {
# Jei yra sutampančių statybos metų, parenkame atsitiktinį butą iš jų
random_idx <- sample(matching_indices, 1)
} else {
next
}
# Užpildome duomenis
combined_data[i, "ID_Renovuoto"] <- i
combined_data[i, "Statybos_Metai_Renovuoto"] <- as.character(renovated_data[i, "build_year_renovated"])
combined_data[i, "Statybos_Metai_Skaicius_Renovuoto"] <- renovated_data$construction_year[i]
combined_data[i, "Kaina_Renovuoto"] <- renovated_data[i, "price_renovated"]
combined_data[i, "ID_Nerenovuoto"] <- random_idx
combined_data[i, "Statybos_Metai_Skaicius_Nerenovuoto"] <- non_renovated_data$construction_year[random_idx]
combined_data[i, "Kaina_Nerenovuoto"] <- non_renovated_data[random_idx, "price_non_renovated"]
}
# Pašaliname eilutes su NA reikšmėmis
combined_data_clean <- combined_data[complete.cases(combined_data), ]
# Papildomai pašaliname eilutes, kur Kaina_Renovuoto yra 0
combined_data_clean <- combined_data_clean[combined_data_clean$Kaina_Renovuoto > 0, ]
par(mfrow=c(2,2))
hist(combined_data_clean$Kaina_Renovuoto, main="Renovuotų butų kainų pasiskirstymas",
xlab="Kaina (EUR)", col="skyblue")
hist(combined_data_clean$Kaina_Nerenovuoto, main="Nerenovuotų butų kainų pasiskirstymas",
xlab="Kaina (EUR)", col="skyblue")
# QQ grafikai
qqnorm(combined_data_clean$Kaina_Renovuoto, main="Renovuotų butų QQ grafikas")
qqline(combined_data_clean$Kaina_Renovuoto)
qqnorm(combined_data_clean$Kaina_Nerenovuoto, main="Nerenovuotų butų QQ grafikas")
qqline(combined_data_clean$Kaina_Nerenovuoto)
log_kaina_renovuoto <- log(combined_data_clean$Kaina_Renovuoto)
log_kaina_nerenovuoto <- log(combined_data_clean$Kaina_Nerenovuoto)
hist(log_kaina_renovuoto, main="Log-transformuotos renovuotų butų kainos",
xlab="ln(Kaina)", col="skyblue")
hist(log_kaina_nerenovuoto, main="Log-transformuotos nerenovuotų butų kainos",
xlab="ln(Kaina)", col="skyblue")
qqnorm(log_kaina_renovuoto, main="Log-renovuotų butų QQ grafikas")
qqline(log_kaina_renovuoto)
qqnorm(log_kaina_nerenovuoto, main="Log-nerenovuotų butų QQ grafikas")
qqline(log_kaina_nerenovuoto)
