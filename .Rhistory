x = "Building Type",
y = "Count") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p)
}
# Reset the plot layout
par(mfrow = c(1, 1))
library(ggplot2)
for (type in c("apartments")) {
if (type %in% names(csv_data_list) && "price" %in% colnames(csv_data_list[[type]])) {
# Get price data and create a data frame
df <- data.frame(price = csv_data_list[[type]]$price)
# Create plot object with fixed deprecated features
p <- ggplot(df, aes(x = price)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
fill = "skyblue",
color = "white",
alpha = 0.7) +
geom_density(color = "darkblue", linewidth = 1) + # Fixed: size -> linewidth
labs(title = paste(toupper(type), "Price Distribution"),
x = "Price (EUR)",
y = "Density") +
theme_minimal() +
scale_x_continuous(labels = scales::comma, limits = c(0, 1000000)) +
coord_cartesian(xlim = c(0, 1000000))
# Print the plot
print(p)
}
}
# Boxplot: Area distribution for premises and premises_rent only
premises_types <- c("premises", "premises_rent")
# Create a list to store both plots
boxplot_list <- list()
for (type in premises_types) {
if (type %in% names(csv_data_list) && "area" %in% colnames(csv_data_list[[type]])) {
df <- csv_data_list[[type]]
df$type <- type  # Add type as a column
# Ensure area is numeric
df$area <- as.numeric(gsub(",", ".", as.character(df$area)))
# Create boxplot
p <- ggplot(df, aes(x = type, y = area)) +
geom_boxplot(fill = "lightgreen", outlier.color = "red", outlier.size = 2) +
labs(title = paste("Area Distribution for", toupper(type)),
x = "Real Estate Type",
y = "Area (sq. m)") +
theme_minimal() +
scale_y_continuous(labels = scales::comma, limits = c(0, 1000)) +
coord_cartesian(ylim = c(0, 1000))
# Print the plot
print(p)
} else {
cat("Dataset", type, "is not available or doesn't have 'area' column\n")
}
}
# Scatter Plot: Price vs. Area
for (type in c("house_rent")) {
if (!is.null(csv_data_list[[type]]) && all(c("price", "area") %in% colnames(csv_data_list[[type]]))) {
df <- csv_data_list[[type]]
# Standardize the area column: replace commas with dots and convert to numeric
df$area <- as.numeric(gsub(",", ".", as.character(df$area)))
# Create scatter plot
p <- ggplot(df, aes(x = area, y = price)) +
geom_point(color = "blue", alpha = 0.5) +
labs(title = paste("Price vs. Area for", toupper(type)),
x = "Area (sq. m)",
y = "Price (EUR)") +
theme_minimal() +
scale_y_continuous(labels = scales::comma, limits = c(0, 6000)) +
scale_x_continuous(labels = scales::comma, limits = c(0, 500))
print(p)
}
}
# Bar Chart: Frequency of Building Types for "apartments"
if ("houses" %in% names(csv_data_list) && "building_type" %in% colnames(csv_data_list[["houses"]])) {
df <- csv_data_list[["houses"]]
# Create bar chart
p <- ggplot(df, aes(x = building_type)) +
geom_bar(fill = "skyblue", color = "black") +
labs(title = "Frequency of Building Types for APARTMENTS",
x = "Building Type",
y = "Count") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p)
}
knitr::opts_chunk$set(
echo = TRUE,            # Rodyti kodą
warning = FALSE,        # Nerodyti įspėjimų
message = FALSE,        # Nerodyti pranešimų
fig.align = "center",   # Centruoti paveikslėlius
fig.width = 8,          # Nustatyti paveikslėlių plotį
fig.height = 6,         # Nustatyti paveikslėlių aukštį
out.width = "80%",      # Išvesties plotis dokumente
dpi = 300               # Grafikų rezoliucija
)
# Pagrindinių paketų įkėlimas
library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)
# Duomenų vieta
data_dir <- "C:/Users/zabit/Documents/GitHub/Statistikos-lab-2/data"
# Gauname aplankų pavadinimus
folders <- list.dirs(data_dir, full.names = FALSE, recursive = FALSE)
# Atspausdiname visų aplankų pavadinimus
kable(data.frame(Kategorijos = folders),
caption = "Nekilnojamojo turto duomenų kategorijos") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# CSV failų nuskaitymas į sąrašą
csv_data_list <- list()
for (folder in folders) {
file_path <- file.path(data_dir, folder, "all_cities_20240214.csv")
if (file.exists(file_path)) {
# Bandyti nuskaityti failą
tryCatch({
df <- read.csv(file_path)
csv_data_list[[folder]] <- df
cat("Nuskaityta:", folder, nrow(df), "eilutėmis ir", ncol(df), "stulpeliais\n")
}, error = function(e) {
cat("Klaida nuskaitant", folder, ":", conditionMessage(e), "\n")
})
}
}
# Apibrėžiame kainų ribas išskirčių identifikavimui
min_threshold <- 20          # Minimali patikima kaina eurais
max_threshold <- 25000000    # Maksimali patikima kaina eurais
# Sukuriame rezultatų lentelę
removal_results <- data.frame(
Kategorija = character(),
Pašalinta_eilučių = integer(),
Per_didelės_kainos = integer(),
Per_mažos_kainos = integer(),
stringsAsFactors = FALSE
)
# Tikriname ir šaliname išskirtis kiekviename duomenų rinkinyje
for (type in names(csv_data_list)) {
if (!is.null(csv_data_list[[type]]) && "price" %in% colnames(csv_data_list[[type]])) {
# Identifikuojame kraštutines reikšmes
extreme_high <- sum(csv_data_list[[type]]$price > max_threshold, na.rm = TRUE)
extreme_low <- sum(csv_data_list[[type]]$price < min_threshold, na.rm = TRUE)
extreme_total <- extreme_high + extreme_low
if (extreme_total > 0) {
# Išsaugome pradinį eilučių skaičių
original_count <- nrow(csv_data_list[[type]])
# Filtruojame duomenis, išlaikydami tik patikimas kainas arba NA reikšmes
csv_data_list[[type]] <- csv_data_list[[type]][
(csv_data_list[[type]]$price >= min_threshold &
csv_data_list[[type]]$price <= max_threshold) |
is.na(csv_data_list[[type]]$price), ]
# Fiksuojame rezultatus
new_count <- nrow(csv_data_list[[type]])
removed_count <- original_count - new_count
# Pridedame rezultatus į suvestinę
removal_results <- rbind(removal_results, data.frame(
Kategorija = type,
Pašalinta_eilučių = removed_count,
Per_didelės_kainos = extreme_high,
Per_mažos_kainos = extreme_low
))
}
}
}
# Atvaizduojame išskirčių šalinimo rezultatus
if (nrow(removal_results) > 0) {
kable(removal_results,
caption = "Išskirčių šalinimo rezultatų suvestinė") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
} else {
cat("Duomenyse nerasta kainų, kurios viršytų nustatytas ribas.")
}
# Patikriname duomenų rinkinių dydžius po valymo
data_sizes <- data.frame(
Eilučių_skaičius = sapply(csv_data_list, nrow),
Stulpelių_skaičius = sapply(csv_data_list, ncol)
)
kable(data_sizes,
caption = "Duomenų rinkinių dydžiai po išskirčių šalinimo") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# Output summary of data
cat("\nColumn names of all loaded datasets:\n")
for (folder_name in names(csv_data_list)) {
cat("\nDataset from folder:", folder_name, "\n")
cat("Column names:", paste(colnames(csv_data_list[[folder_name]]), collapse = ", "), "\n")
}
# Get all unique column names across all datasets
all_columns <- unique(unlist(lapply(csv_data_list, colnames)))
unique_columns <- sort(all_columns)
# Display unique column names and count
cat("Total unique columns across all datasets:", length(unique_columns), "\n")
cat("Unique column names:", paste(unique_columns, collapse = ", "), "\n")
# Display sample values for each unique column
cat("Sample values for each unique column:\n")
for (col_name in unique_columns) {
cat("\n", col_name, ":\n")
found_values <- FALSE
# Look for this column in each dataset
for (dataset_name in names(csv_data_list)) {
df <- csv_data_list[[dataset_name]]
# Check if this column exists in the current dataset
if (col_name %in% colnames(df)) {
# Extract non-NA values
non_na_values <- df[[col_name]][!is.na(df[[col_name]])]
# If we have non-NA values
if (length(non_na_values) > 0) {
# Take up to 2 samples
sample_size <- min(2, length(non_na_values))
samples <- non_na_values[1:sample_size]
# Display the samples with the dataset name
cat("  From ", dataset_name, ": ",
paste(samples, collapse = ", "),
if(length(non_na_values) > 3) " ..." else "", "\n", sep = "")
found_values <- TRUE
break  # Only show from one dataset to keep output manageable
}
}
}
if (!found_values) {
cat("  No non-NA values found in any dataset\n")
}
}
# Analizuojame duomenų rinkinių stulpelių struktūrą
# Sukuriame lentelę su stulpelių sąrašais kiekvienam duomenų rinkiniui
columns_by_dataset <- data.frame(
Duomenų_rinkinys = character(),
Stulpelių_skaičius = integer(),
Stulpelių_pavadinimai = character(),
stringsAsFactors = FALSE
)
# Pildome lentelę informacija apie stulpelius
for (folder_name in names(csv_data_list)) {
columns_by_dataset <- rbind(columns_by_dataset, data.frame(
Duomenų_rinkinys = folder_name,
Stulpelių_skaičius = ncol(csv_data_list[[folder_name]]),
Stulpelių_pavadinimai = paste(colnames(csv_data_list[[folder_name]]), collapse = ", ")
))
}
# Atvaizduojame lentelę su stulpelių informacija
kable(columns_by_dataset,
caption = "Kiekvieno duomenų rinkinio stulpelių struktūra") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
column_spec(3, width = "50em") %>%
scroll_box(width = "100%", height = "400px")
# Randame unikalius stulpelių pavadinimus visuose duomenų rinkiniuose
all_columns <- unique(unlist(lapply(csv_data_list, colnames)))
unique_columns <- sort(all_columns)
# Analizuojame stulpelių pasikartojimą skirtinguose duomenų rinkiniuose
column_presence <- data.frame(
Stulpelis = unique_columns,
Pasikartojimų_skaičius = sapply(unique_columns, function(col) {
sum(sapply(csv_data_list, function(df) col %in% colnames(df)))
}),
stringsAsFactors = FALSE
)
# Rikiuojame pagal pasikartojimų skaičių mažėjimo tvarka
column_presence <- column_presence[order(column_presence$Pasikartojimų_skaičius, decreasing = TRUE),]
# Atvaizduojame unikalių stulpelių analizę
kable(column_presence,
caption = paste("Unikalių stulpelių pasikartojimas duomenų rinkiniuose (iš viso:", nrow(column_presence), "stulpeliai)")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
scroll_box(width = "100%", height = "300px")
# Analizuojame duomenų rinkinių stulpelių struktūrą
# Sukuriame lentelę su stulpelių sąrašais kiekvienam duomenų rinkiniui
columns_by_dataset <- data.frame(
Duomenų_rinkinys = character(),
knitr::opts_chunk$set(
echo = TRUE,            # Rodyti kodą
warning = FALSE,        # Nerodyti įspėjimų
message = FALSE,        # Nerodyti pranešimų
fig.align = "center",   # Centruoti paveikslėlius
fig.width = 8,          # Nustatyti paveikslėlių plotį
fig.height = 6,         # Nustatyti paveikslėlių aukštį
out.width = "80%",      # Išvesties plotis dokumente
dpi = 300               # Grafikų rezoliucija
)
# Pagrindinių paketų įkėlimas
library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)
# Duomenų vieta
data_dir <- "C:/Users/zabit/Documents/GitHub/Statistikos-lab-2/data"
# Gauname aplankų pavadinimus
folders <- list.dirs(data_dir, full.names = FALSE, recursive = FALSE)
# Atspausdiname visų aplankų pavadinimus
kable(data.frame(Kategorijos = folders),
caption = "Nekilnojamojo turto duomenų kategorijos") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# CSV failų nuskaitymas į sąrašą
csv_data_list <- list()
for (folder in folders) {
file_path <- file.path(data_dir, folder, "all_cities_20240214.csv")
if (file.exists(file_path)) {
# Bandyti nuskaityti failą
tryCatch({
df <- read.csv(file_path)
csv_data_list[[folder]] <- df
cat("Nuskaityta:", folder, nrow(df), "eilutėmis ir", ncol(df), "stulpeliais\n")
}, error = function(e) {
cat("Klaida nuskaitant", folder, ":", conditionMessage(e), "\n")
})
}
}
# Apibrėžiame kainų ribas išskirčių identifikavimui
min_threshold <- 20          # Minimali kaina eurais
max_threshold <- 25000000    # Maksimali kaina eurais
# Sukuriame rezultatų lentelę
removal_results <- data.frame(
Kategorija = character(),
Pašalinta_eilučių = integer(),
knitr::opts_chunk$set(
echo = TRUE,            # Rodyti kodą
warning = FALSE,        # Nerodyti įspėjimų
message = FALSE,        # Nerodyti pranešimų
fig.align = "center",   # Centruoti paveikslėlius
fig.width = 8,          # Nustatyti paveikslėlių plotį
fig.height = 6,         # Nustatyti paveikslėlių aukštį
out.width = "80%",      # Išvesties plotis dokumente
dpi = 300               # Grafikų rezoliucija
)
# Pagrindinių paketų įkėlimas
library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)
# Duomenų vieta
data_dir <- "C:/Users/zabit/Documents/GitHub/Statistikos-lab-2/data"
# Gauname aplankų pavadinimus
folders <- list.dirs(data_dir, full.names = FALSE, recursive = FALSE)
# Atspausdiname visų aplankų pavadinimus
kable(data.frame(Kategorijos = folders),
caption = "Nekilnojamojo turto duomenų kategorijos") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# CSV failų nuskaitymas į sąrašą
csv_data_list <- list()
for (folder in folders) {
file_path <- file.path(data_dir, folder, "all_cities_20240214.csv")
if (file.exists(file_path)) {
# Bandyti nuskaityti failą
tryCatch({
df <- read.csv(file_path)
csv_data_list[[folder]] <- df
cat("Nuskaityta:", folder, nrow(df), "eilutėmis ir", ncol(df), "stulpeliais\n")
}, error = function(e) {
cat("Klaida nuskaitant", folder, ":", conditionMessage(e), "\n")
})
}
}
# Apibrėžiame kainų ribas išskirčių identifikavimui
min_threshold <- 20          # Minimali kaina eurais
max_threshold <- 25000000    # Maksimali kaina eurais
# Sukuriame rezultatų lentelę
removal_results <- data.frame(
Kategorija = character(),
Pašalinta_eilučių = integer(),
knitr::opts_chunk$set(
echo = TRUE,            # Rodyti kodą
warning = FALSE,        # Nerodyti įspėjimų
message = FALSE,        # Nerodyti pranešimų
fig.align = "center",   # Centruoti paveikslėlius
fig.width = 8,          # Nustatyti paveikslėlių plotį
fig.height = 6,         # Nustatyti paveikslėlių aukštį
out.width = "80%",      # Išvesties plotis dokumente
dpi = 300               # Grafikų rezoliucija
)
# Pagrindinių paketų įkėlimas
library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)
# Duomenų vieta
data_dir <- "C:/Users/zabit/Documents/GitHub/Statistikos-lab-2/data"
# Gauname aplankų pavadinimus
folders <- list.dirs(data_dir, full.names = FALSE, recursive = FALSE)
# Atspausdiname visų aplankų pavadinimus
kable(data.frame(Kategorijos = folders),
caption = "Nekilnojamojo turto duomenų kategorijos") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# CSV failų nuskaitymas į sąrašą
csv_data_list <- list()
for (folder in folders) {
file_path <- file.path(data_dir, folder, "all_cities_20240214.csv")
if (file.exists(file_path)) {
# Bandyti nuskaityti failą
tryCatch({
df <- read.csv(file_path)
csv_data_list[[folder]] <- df
cat("Nuskaityta:", folder, nrow(df), "eilutėmis ir", ncol(df), "stulpeliais\n")
}, error = function(e) {
cat("Klaida nuskaitant", folder, ":", conditionMessage(e), "\n")
})
}
}
# Apibrėžiame kainų ribas išskirčių identifikavimui
min_threshold <- 20          # Minimali kaina eurais
max_threshold <- 25000000    # Maksimali kaina eurais
# Sukuriame rezultatų lentelę
removal_results <- data.frame(
Kategorija = character(),
Pašalinta_eilučių = integer(),
# Apibrėžiame kainų ribas išskirčių identifikavimui
min_threshold <- 20          # Minimali kaina eurais
max_threshold <- 25000000    # Maksimali kaina eurais
# Sukuriame rezultatų lentelę
removal_results <- data.frame(
Kategorija = character(),
Pasalinta_eiluciu = integer(),
Per_dideles_kainos = integer(),
Per_mazos_kainos = integer(),
stringsAsFactors = FALSE
)
# Tikriname ir šaliname išskirtis kiekviename duomenų rinkinyje
for (type in names(csv_data_list)) {
if (!is.null(csv_data_list[[type]]) && "price" %in% colnames(csv_data_list[[type]])) {
# Identifikuojame kraštutines reikšmes
extreme_high <- sum(csv_data_list[[type]]$price > max_threshold, na.rm = TRUE)
extreme_low <- sum(csv_data_list[[type]]$price < min_threshold, na.rm = TRUE)
extreme_total <- extreme_high + extreme_low
if (extreme_total > 0) {
# Išsaugome pradinį eilučių skaičių
original_count <- nrow(csv_data_list[[type]])
# Filtruojame duomenis, išlaikydami tik patikimas kainas arba NA reikšmes
csv_data_list[[type]] <- csv_data_list[[type]][
(csv_data_list[[type]]$price >= min_threshold &
csv_data_list[[type]]$price <= max_threshold) |
is.na(csv_data_list[[type]]$price), ]
# Fiksuojame rezultatus
new_count <- nrow(csv_data_list[[type]])
removed_count <- original_count - new_count
# Pridedame rezultatus į suvestinę
removal_results <- rbind(removal_results, data.frame(
Kategorija = type,
Pašalinta_eilučių = removed_count,
# Apibrėžiame kainų ribas išskirčių identifikavimui
min_threshold <- 20          # Minimali kaina eurais
max_threshold <- 25000000    # Maksimali kaina eurais
# Sukuriame rezultatų lentelę
removal_results <- data.frame(
Kategorija = character(),
Pasalinta_eiluciu = integer(),
Per_dideles_kainos = integer(),
Per_mazos_kainos = integer(),
stringsAsFactors = FALSE
)
# Tikriname ir šaliname išskirtis kiekviename duomenų rinkinyje
for (type in names(csv_data_list)) {
if (!is.null(csv_data_list[[type]]) && "price" %in% colnames(csv_data_list[[type]])) {
# Identifikuojame kraštutines reikšmes
extreme_high <- sum(csv_data_list[[type]]$price > max_threshold, na.rm = TRUE)
extreme_low <- sum(csv_data_list[[type]]$price < min_threshold, na.rm = TRUE)
extreme_total <- extreme_high + extreme_low
if (extreme_total > 0) {
# Išsaugome pradinį eilučių skaičių
original_count <- nrow(csv_data_list[[type]])
# Filtruojame duomenis, išlaikydami tik patikimas kainas arba NA reikšmes
csv_data_list[[type]] <- csv_data_list[[type]][
(csv_data_list[[type]]$price >= min_threshold &
csv_data_list[[type]]$price <= max_threshold) |
is.na(csv_data_list[[type]]$price), ]
# Fiksuojame rezultatus
new_count <- nrow(csv_data_list[[type]])
removed_count <- original_count - new_count
# Pridedame rezultatus į suvestinę
removal_results <- rbind(removal_results, data.frame(
Kategorija = type,
Pašalinta_eilučių = removed_count,
knitr::opts_chunk$set(
echo = TRUE,            # Rodyti kodą
warning = FALSE,        # Nerodyti įspėjimų
message = FALSE,        # Nerodyti pranešimų
fig.align = "center",   # Centruoti paveikslėlius
fig.width = 8,          # Nustatyti paveikslėlių plotį
fig.height = 6,         # Nustatyti paveikslėlių aukštį
out.width = "80%",      # Išvesties plotis dokumente
dpi = 300               # Grafikų rezoliucija
)
# Pagrindinių paketų įkėlimas
library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)
# Duomenų vieta
data_dir <- "C:/Users/zabit/Documents/GitHub/Statistikos-lab-2/data"
# Gauname aplankų pavadinimus
folders <- list.dirs(data_dir, full.names = FALSE, recursive = FALSE)
# Atspausdiname visų aplankų pavadinimus
kable(data.frame(Kategorijos = folders),
caption = "Nekilnojamojo turto duomenų kategorijos") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# CSV failų nuskaitymas į sąrašą
csv_data_list <- list()
for (folder in folders) {
file_path <- file.path(data_dir, folder, "all_cities_20240214.csv")
if (file.exists(file_path)) {
# Bandyti nuskaityti failą
tryCatch({
df <- read.csv(file_path)
csv_data_list[[folder]] <- df
cat("Nuskaityta:", folder, nrow(df), "eilutėmis ir", ncol(df), "stulpeliais\n")
}, error = function(e) {
cat("Klaida nuskaitant", folder, ":", conditionMessage(e), "\n")
})
}
}
# Apibrėžiame kainų ribas išskirčių identifikavimui
min_threshold <- 20          # Minimali kaina eurais
max_threshold <- 25000000    # Maksimali kaina eurais
# Sukuriame rezultatų lentelę
removal_results <- data.frame(
Kategorija = character(),
Pašalinta_eilučių = integer(),
