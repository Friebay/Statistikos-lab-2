---
title: "Statistikos laboratorinis darbas Nr. 2"
author: "VU"
date: "2025-03-27"
output:
  pdf_document:
    toc: true
    latex_engine: xelatex
  html_document:
    toc: true
    toc_float: true
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

1.  Aprašykite turimus duomenis, nurodykite duomenų šaltinį.

Duomenys atsisiųsti iš <https://github.com/valdas-v1/lithuanian-real-estate-listings>. Duomenys buvo surinkti 2024 m. vasarį iš <https://www.aruodas.lt/> puslapio. Duomenų rinkinyje yra informacija apie parduodamus ir nuomojamus butus, garažus, namus, sklypus ir patalpas.

```{r}
# Set the path to the data directory
data_dir <- "C:/Users/zabit/Documents/GitHub/Statistikos-lab-2/data"

# Get all folder names inside the data directory
folders <- list.dirs(data_dir, full.names = FALSE, recursive = FALSE)

# Print all folder names
print(folders)

# Check if all folders have the file "all_cities_20240214.csv"
all_have_file <- TRUE
folders_with_file <- 0
folders_missing_file <- character(0)

for (folder in folders) {
  file_path <- file.path(data_dir, folder, "all_cities_20240214.csv")
  if (file.exists(file_path)) {
    folders_with_file <- folders_with_file + 1
  } else {
    all_have_file <- FALSE
    folders_missing_file <- c(folders_missing_file, folder)
  }
}
```

```{r}
# Read the CSV files into a list of dataframes
csv_data_list <- list()

for (folder in folders) {
  file_path <- file.path(data_dir, folder, "all_cities_20240214.csv")
  if (file.exists(file_path)) {
    # Try reading the file
    tryCatch({
      df <- read.csv(file_path)
      csv_data_list[[folder]] <- df
      cat("Read:", folder, "with", nrow(df), "rows and", ncol(df), "columns\n")
    }, error = function(e) {
      cat("Error", folder, ":", conditionMessage(e), "\n")
    })
  }
}
```

Ieškome galimai neteisingai įvestų duomenų.

```{r}
# Remove rows with extreme prices (price > 50,000,000 or price < 20)
for (type in names(csv_data_list)) {
  if (!is.null(csv_data_list[[type]]) && "price" %in% colnames(csv_data_list[[type]])) {
    # Count rows with extreme prices
    extreme_high <- sum(csv_data_list[[type]]$price > 50000000, na.rm = TRUE)
    extreme_low <- sum(csv_data_list[[type]]$price < 20, na.rm = TRUE)
    extreme_prices <- extreme_high + extreme_low
    
    if (extreme_prices > 0) {
      # Store original row count
      original_count <- nrow(csv_data_list[[type]])
      
      # Remove rows with extreme prices, keep rows where price is within range or NA
      csv_data_list[[type]] <- csv_data_list[[type]][(csv_data_list[[type]]$price >= 20 & 
                                                     csv_data_list[[type]]$price <= 50000000) | 
                                                     is.na(csv_data_list[[type]]$price), ]
      
      # Verify how many rows were removed
      new_count <- nrow(csv_data_list[[type]])
      removed_count <- original_count - new_count
      
      cat(type, ": Removed ", removed_count, " rows with extreme prices (", extreme_high, 
          " high, ", extreme_low, " low)\n", sep="")
    } else {
      cat(type, ": No rows with extreme prices\n", sep="")
    }
  } else if (!is.null(csv_data_list[[type]])) {
    cat(type, ": No price column found\n", sep="")
  }
}
```

```{r}
# Output summary of data
cat("\nSummary of all loaded datasets:\n")
for (folder_name in names(csv_data_list)) {
  cat("\nDataset from folder:", folder_name, "\n")
  cat("Number of rows:", nrow(csv_data_list[[folder_name]]), "\n")
  cat("Number of columns:", ncol(csv_data_list[[folder_name]]), "\n")
  cat("Column names:", paste(colnames(csv_data_list[[folder_name]]), collapse = ", "), "\n")
}

# Get all unique column names across all datasets
all_columns <- unique(unlist(lapply(csv_data_list, colnames)))
unique_columns <- sort(all_columns)

# Display unique column names and count
cat("Total unique columns across all datasets:", length(unique_columns), "\n")
cat("Unique column names:", paste(unique_columns, collapse = ", "), "\n")

# Display sample values for each unique column
cat("Sample values for each unique column:\n")
for (col_name in unique_columns) {
  cat("\n", col_name, ":\n")
  found_values <- FALSE
  
  # Look for this column in each dataset
  for (dataset_name in names(csv_data_list)) {
    df <- csv_data_list[[dataset_name]]
    
    # Check if this column exists in the current dataset
    if (col_name %in% colnames(df)) {
      # Extract non-NA values
      non_na_values <- df[[col_name]][!is.na(df[[col_name]])]
      
      # If we have non-NA values
      if (length(non_na_values) > 0) {
        # Take up to 3 samples
        sample_size <- min(3, length(non_na_values))
        samples <- non_na_values[1:sample_size]
        
        # Display the samples with the dataset name
        cat("  From ", dataset_name, ": ", 
            paste(samples, collapse = ", "), 
            if(length(non_na_values) > 3) " ..." else "", "\n", sep = "")
        
        found_values <- TRUE
        break  # Only show from one dataset to keep output manageable
      }
    }
  }
  
  if (!found_values) {
    cat("  No non-NA values found in any dataset\n")
  }
}
```

```{r}
# Real estate types to analyze
real_estate_types <- c("apartments", "houses", "land", "premises")

for (type in real_estate_types) {
  cat("\n----------\n", toupper(type), "PRICE SUMMARY\n")
  
  # Check if this real estate type exists in our list
  if (type %in% names(csv_data_list)) {
    df <- csv_data_list[[type]]
    
    # Check if price column exists
    if ("price" %in% colnames(df)) {
      # Extract price data
      prices <- df$price
      
      # Generate summary statistics
      cat("Number of observations:", length(prices), "\n")
      cat("Summary statistics:\n")
      print(summary(prices))
      
      # Additional statistics
      cat("\nStandard deviation:", sd(prices, na.rm = TRUE), "\n")
    }
  }
}
```

```{r}
library(ggplot2)

# Real estate types to analyze
real_estate_types <- c("apartments", "houses", "land", "premises")

# Reset the plot layout
par(mfrow = c(1, 1))

price_data <- data.frame()

for (type in real_estate_types) {
  if (type %in% names(csv_data_list) && "price" %in% colnames(csv_data_list[[type]])) {
    # Extract prices and create a data frame
    temp_data <- data.frame(
      price = csv_data_list[[type]]$price,
      type = rep(type, length(csv_data_list[[type]]$price))
    )
    price_data <- rbind(price_data, temp_data)
  }
}

# Create combined box plot if we have data
if (nrow(price_data) > 0) {
  ggplot(price_data, aes(x = type, y = price, fill = type)) +
    geom_boxplot(outlier.size = 1) +
    scale_y_continuous(labels = scales::comma) +
    labs(title = "Price Distribution Across Real Estate Types",
         x = "Real Estate Type",
         y = "Price (EUR)") +
    theme_minimal() +
    theme(legend.position = "none")
}

# Create combined box plot if we have data
if (nrow(price_data) > 0) {
  ggplot(price_data, aes(x = type, y = price, fill = type)) +
    geom_boxplot(outlier.size = 1) +
    scale_y_continuous(labels = scales::comma,
                       limits = c(NA, 1000000)) + # Set the upper limit
    labs(title = "Price Distribution Across Real Estate Types",
         x = "Real Estate Type",
         y = "Price (EUR)") +
    theme_minimal() +
    theme(legend.position = "none")
}
```

```{r}

# Reset the plot layout
par(mfrow = c(1, 1))

for (type in real_estate_types) {
  if (type %in% names(csv_data_list) && "price" %in% colnames(csv_data_list[[type]])) {
    # Get price data and create a data frame
    df <- data.frame(price = csv_data_list[[type]]$price)
    
    # Create plot object with fixed deprecated features
    p <- ggplot(df, aes(x = price)) +
      geom_histogram(aes(y = after_stat(density)),
                     bins = 30, 
                     fill = "skyblue", 
                     color = "white", 
                     alpha = 0.7) +
      geom_density(color = "darkblue", linewidth = 1) + # Fixed: size -> linewidth
      labs(title = paste(toupper(type), "Price Distribution"),
           x = "Price (EUR)",
           y = "Density") +
      theme_minimal() +
      scale_x_continuous(labels = scales::comma, limits = c(0, 1000000)) +
      coord_cartesian(xlim = c(0, 1000000))
    
    # Print the plot
    print(p)
  }
}
```

2.  Išbrėžkite turimų duomenų grafikus (parinkite tinkamiausius). Manau kokių 4 užtektų

3.  Apskaičiuokite pagrindines skaitines charakteristikas kiekybiniams kintamiesiems. Vidurkis (Mean), Mediana (Median), Moda (Mode), Dispersija (Variance), Standartinis nuokrypis (Standard Deviation), Kvartiliai (Quartiles), Tarpkvartilinis plotis (Interquartile Range, IQR), Diapazonas (Range, max-min)
Kiekybiniai duomenys: kaina ("price"), peržiūrų skaičius ("views_total"), būsto dydis ("area" iš apartments), žemės ploto dydis ("area_.a." iš land), build_year iš apartments, buto aukštas ("floor"), kambarių skaičius ("number_of_rooms"), plot_area, price_per_month.

```{r}
# Filter the dataframes that contain the "price" column
dataframes_with_price <- csv_data_list[sapply(csv_data_list, function(df) "price" %in% colnames(df))]

# Print the names of the datasets that contain the "price" column
print(names(dataframes_with_price))
```

```{r}
# Filter the dataframes that contain the "price_per_month" column
dataframes_with_price_per_month <- csv_data_list[sapply(csv_data_list, function(df) "price_per_month" %in% colnames(df))]

# Print the names of the datasets that contain the "price_per_month" column
print(names(dataframes_with_price_per_month))
```

```{r}
# Filter the dataframes that contain the "views_total" column
dataframes_with_views_total <- csv_data_list[sapply(csv_data_list, function(df) "views_total" %in% colnames(df))]

# Print the names of the datasets that contain the "views_total" column
print(names(dataframes_with_views_total))
```

```{r}
# Filter the dataframes that contain the "area" column
dataframes_with_area <- csv_data_list[sapply(csv_data_list, function(df) "area" %in% colnames(df))]

# Print the names of the datasets that contain the "area" column
print(names(dataframes_with_area))
```

```{r}
# Filter the dataframes that contain the "area" column
dataframes_with_area_a <- csv_data_list[sapply(csv_data_list, function(df) "area_.a." %in% colnames(df))]

# Print the names of the datasets that contain the "area_.a" column
print(names(dataframes_with_area_a))
```

```{r}
# Filter the dataframes that contain the "build_year" column
dataframes_with_build_year <- csv_data_list[sapply(csv_data_list, function(df) "build_year" %in% colnames(df))]

# Print the names of the datasets that contain the "build_year" column
print(names(dataframes_with_build_year))
```

```{r}
# Filter the dataframes that contain the "floor" column
dataframes_with_floor <- csv_data_list[sapply(csv_data_list, function(df) "floor" %in% colnames(df))]

# Print the names of the datasets that contain the "floor" column
print(names(dataframes_with_floor))
```
```{r}
# Filter the dataframes that contain the "number_of_rooms" column
dataframes_with_number_of_rooms <- csv_data_list[sapply(csv_data_list, function(df) "number_of_rooms" %in% colnames(df))]

# Print the names of the datasets that contain the "number_of_rooms" column
print(names(dataframes_with_number_of_rooms))
```

```{r}
# Filter the dataframes that contain the "plot_area" column
dataframes_with_plot_area <- csv_data_list[sapply(csv_data_list, function(df) "plot_area" %in% colnames(df))]

# Print the names of the datasets that contain the "plot_area" column
print(names(dataframes_with_plot_area))
```

4.  Sudarykite dažnių lenteles kategoriniams kintamiesiems.

5.  Suformuluokite bent 6 tyrimo hipotezes iš savo duomenų rinkinio

6.  Užrašykite kokius testus parinkote savo tyrimo hipotezėms. Hipotezės turi būti skirtos skirtingų testų naudojimui. Jei reikia susikurkite naujus kintamuosius iš turimų duomenų.

7.  Patikrinkite, ar kintamieji tenkina būtinas sąlygas testų taikymui. Jei netenkina, atlikite duomenų transformacijas.

8.  Atlikite statistinį tyrimą savo suformuluotoms hipotezėms.

9.  Pateikite tyrimo atsakymą.
